# 권고 사항
- `supabase auth`에는 여러 문제가 존재함
    - 코드베이스에 `불필요한 의존성` 및 `성능 저하` 발생
        - `클라이언트`에서 `로드`해야 함(퍼포먼스 이슈)
        - `트리셰이킹`도 불가능
            - `netlify`의 `GoTrue client` 기반으로 extend하는, `Class 사용`으로 발생하는 문제
    - DB `벤더 이전 시`, `전체를 리팩토링` 해야 함
        - 서비스의 DB 종속성 심화
- 이를 해소하고자 직접 인증을 구현하고자 할 수 있음
- 하지만 다음의 이유로 `client-side` 인증을 직접 구현하는 일은 `절대 바람직하지 않음`
- 일반적으로는 인증 절차는 `서버`에서 처리해야 함

## pain-point
### 1. 회원가입 시, 비밀번호를 평문으로 전송하는 문제
- 별도의 서버 스크립트 없이 `POST` 요청을 직접 DB로 보내면, DB에서 `비밀번호를 평문`으로 저장하게 됨
- `평문 저장`의 여러 문제로 인해 `암호화`가 필요

### 2. client-side 해시/검증의 문제 
- `기술적으로`는 client-side에서 `hash-wasm` 등을 통해 해시할 수 있음
    - 이는 client-side에서의 작동 결과를 완전히 신뢰해야 하는 문제가 있음
- 이렇게 클라이언트에서 해시된 암호를 DB에 저장한다고 해도, DB에서 직접 `검증`할 수 없음
    - `기술적으로`는 `salt를 고정`하면 DB에서 일치를 확인하는 식으로 `검증`할 수 있음
    - 그러나 `salt를 고정`하는 순간, 전체 DB 해시 브루트 포스에 대한 `시간 복잡도`는 급격하게 `감소`
    - 클라이언트에 코드가 노출되어 있으므로 `암호화 방식`도 모두 `노출`됨
    - 충분한 컴퓨팅 파워만 있다면 해시에 대응되는 비밀번호를 찾을 수 있게 됨
- 암호를 DB에서 검증할 수 없으므로, DB에서 🚨`암호화 된 비밀번호를 DB로부터 받아`🚨 🚨`클라이언트`에서 `검증`🚨해야 함 
- 또한 `검증 결과`를 DB에 보내고, DB는 그 값을 신뢰하고 로그인 처리를 해야 함

### 3. client-side token 발행의 문제
- 클라이언트에서 토큰을 만들 수 있다고 해도 이는 무의미함
- 환경 변수에서 불러온다고 하더라도 기본적으로 클라이언트에서 실제 작동하는 코드에는 `jwt secret`이 `노출`됨🤔
- 결국 누구나 토큰을 완전히 임의로 생성할 수 있다는 뜻임
- 🚨`토큰 생성 방법`🚨이 완전히 🚨`노출`🚨될 경우 보안은 무의미함
    - 큰 악의적 코드 실행 없이 `window.localStorage.setItem(KEY, VALUE)`를 개발자 도구에서 실행하는 것으로도 토큰을 💀위조💀할 수 있음

## 결론
### client-side auth의 한계
- 서버에서 DB와 독립적으로 작동하는 별도 코드가 존재하지 않는 현재 프로젝트 구조에서는 완전한 auth 체계가 성립되지 않음
- `액세스 토큰` 생성 관련 코드를 클라이언트에서 실행하는 순간 모든 조치는 무의미함
- 토큰을 쓰지 않을 수 있지만 이 경우 
    - 비밀번호를 상태로 관리해야 하고, 
    - 매 요청에 비밀번호를 포함시키며, 
    - 새로고침 시 로그아웃 되는 
    문제가 있음
- `토큰` 없이 새로고침 시 로그아웃되는 문제를 해결하려면 
    - `redux-persist`와 같이 유지되는(저장하는) 상태 관리 기능과 함께
    - 비밀번호를 해시화 하여 `상태로 관리/저장`하고
    - `salt를 고정`하며(DB에서 검증 목적)
    - `매 요청`에 대해 `DB에서 검증`해야 함    

- 여러 보안 위험이 존재하므로 `supabase auth`를 통해 보안 절차를 진행하거나
- `서버`에서 보안 절차를 진행하는 것이 바람직함